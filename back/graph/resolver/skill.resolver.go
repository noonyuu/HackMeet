package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/noonyuu/nfc/back/graph"
	"github.com/noonyuu/nfc/back/graph/model"
)

// CreateSkill is the resolver for the createSkill field.
func (r *mutationResolver) CreateSkill(ctx context.Context, input model.NewSkill) (*model.Skill, error) {
	// uuidを生成
	uid, _ := uuid.NewRandom()
	// 生成したUUIDを文字列に変換
	uidString := uid.String()
	// 現在時刻を取得
	now := time.Now()
	// Skill構造体にUUIDと現在時刻をセット
	skill := &model.Skill{
		ID:        uidString,
		Name:      input.Name,
		Category:  input.Category,
		CreatedAt: now,
		UpdatedAt: now,
	}

	query := `
		INSERT INTO skills (id, name, category, created_at, updated_at)
		VALUES (?, ?, ?, ?, ?)
	`
	_, err := r.DB.Exec(query, skill.ID, skill.Name, skill.Category, now, now)
	if err != nil {
		log.Printf("failed to insert skill: %v", err)

		return nil, &gqlerror.Error{
			Message: "スキルの登録に失敗しました。",
			Extensions: map[string]interface{}{
				"code":  "INTERNAL_SERVER_ERROR",
			},
		},
	}

	return skill, nil
}

// SkillByName is the resolver for the skillByName field.
func (r *queryResolver) SkillByName(ctx context.Context, name string) (*model.Skill, error) {
	query := `
		SELECT id, name, category, created_at, updated_at
		FROM skills
		WHERE name = ?
	`
	row := r.DB.QueryRow(query, name)
	var skill model.Skill
	if err := row.Scan(&skill.ID, &skill.Name, &skill.Category, &skill.CreatedAt, &skill.UpdatedAt); err != nil {
		log.Printf("failed to query skill by name: %v", err)
		
		return nil, &gqlerror.Error{
			Message: "スキルの取得に失敗しました。",
			Extensions: map[string]interface{}{
				"code":  "INTERNAL_SERVER_ERROR",
			},
		},
	}
	// スキルを返す
	return &skill, nil
}

// Skills is the resolver for the skills field.
func (r *queryResolver) Skills(ctx context.Context) ([]*model.Skill, error) {
	query := `
		SELECT id, name, category, created_at, updated_at
		FROM skills
	`
	rows, err := r.DB.Query(query)
	if err != nil {
		log.Printf("failed to query skills: %v", err)
		
		return nil, &gqlerror.Error{
			Message: "スキルの取得中にサーバーエラーが発生しました。",
			Extensions: map[string]interface{}{
				"code": "INTERNAL_SERVER_ERROR",
			},
		},
	}
	defer rows.Close()

	var skills []*model.Skill
	for rows.Next() {
		var skill model.Skill
		if err := rows.Scan(&skill.ID, &skill.Name, &skill.Category, &skill.CreatedAt, &skill.UpdatedAt); err != nil {
			log.Printf("failed to scan skill: %v", err)

			return nil, &gqlerror.Error{
				Message: "スキルの取得中にサーバーエラーが発生しました。",
				Extensions: map[string]interface{}{
					"code": "INTERNAL_SERVER_ERROR",
				},
			},
		}
		skills = append(skills, &skill)
	}

	if err := rows.Err(); err != nil {
		log.Printf("error iterating over skills: %v", err)
		
		return nil, &gqlerror.Error{
			Message: "スキルの取得中にサーバーエラーが発生しました。",
			Extensions: map[string]interface{}{
				"code": "INTERNAL_SERVER_ERROR",
			},
		},
	}

	return skills, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *skillResolver) CreatedAt(ctx context.Context, obj *model.Skill) (string, error) {
	return obj.CreatedAt.Format("2006-01-02 15:04:05"), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *skillResolver) UpdatedAt(ctx context.Context, obj *model.Skill) (string, error) {
	return obj.UpdatedAt.Format("2006-01-02 15:04:05"), nil
}

// Skill returns graph.SkillResolver implementation.
func (r *Resolver) Skill() graph.SkillResolver { return &skillResolver{r} }

type skillResolver struct{ *Resolver }
