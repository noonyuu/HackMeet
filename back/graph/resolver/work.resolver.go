package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/noonyuu/nfc/back/graph"
	"github.com/noonyuu/nfc/back/graph/model"
	"github.com/noonyuu/nfc/back/util"
	"github.com/vektah/gqlparser/gqlerror"
)

// CreateWork is the resolver for the createWork field.
func (r *mutationResolver) CreateWork(ctx context.Context, input model.NewWork) (*model.Work, error) {
	uid, _ := uuid.NewRandom()
	uidString := uid.String()
	now := time.Now()
	work := &model.Work{
		ID:          uidString,
		Title:       input.Title,
		Description: "",
		CreatedAt:   now,
		UpdatedAt:   now,
		UserIDs:     input.UserIds,
	}

	if input.Description != nil {
		work.Description = *input.Description
	}

	tx, err := r.DB.BeginTx(ctx, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer func() {
		if p := recover(); p != nil {
			log.Printf("Panic recovered, rolling back: %v", p)
			tx.Rollback()
			panic(p)
		} else if err != nil {
			log.Printf("Error occurred [%v], rolling back.", err)
			if rbErr := tx.Rollback(); rbErr != nil {
				log.Printf("Error during deferred rollback: %v", rbErr)
			}
		} else {
		}
	}()

	query := `
		INSERT INTO works (id, title, description, created_at, updated_at)
		VALUES (?, ?, ?, ?, ?)
	`
	if _, err = tx.ExecContext(ctx, query, work.ID, work.Title, work.Description, now, now); err != nil {
		log.Printf("Error inserting into works with transaction: %v", err)

		return nil, &gqlerror.Error{
			Message: "作品の登録に失敗しました。",
			Extensions: map[string]interface{}{
				"code": "INTERNAL_SERVER_ERROR",
			},
		}
	}

	if input.ImageURL != nil {
		imageQuery := `INSERT INTO images (id, image_url, created_at, updated_at) VALUES (?, ?, ?, ?)`
		workImageQuery := `INSERT INTO work_images (work_id, image_id, created_at, updated_at) VALUES (?, ?, ?, ?)`

		for _, imageUrl := range input.ImageURL {
			imageUID, _ := uuid.NewRandom()
			imageID := imageUID.String()

			if _, err := tx.ExecContext(ctx, imageQuery, imageID, imageUrl, now, now); err != nil {
				log.Printf("Error inserting image with transaction: %v", err)

				return nil, &gqlerror.Error{
					Message: "画像の登録に失敗しました。",
					Extensions: map[string]interface{}{
						"code": "INTERNAL_SERVER_ERROR",
					},
				}
			}

			if _, err := tx.ExecContext(ctx, workImageQuery, work.ID, imageID, now, now); err != nil {
				log.Printf("Error inserting work_image relation with transaction: %v", err)

				return nil, &gqlerror.Error{
					Message: "失敗しました。",
					Extensions: map[string]interface{}{
						"code": "INTERNAL_SERVER_ERROR",
					},
				}
			}
		}
	}

	if input.DiagramImageURL != nil {
		diagramImageQuery := `INSERT INTO diagram_images (id, image_url, created_at, updated_at) VALUES (?, ?, ?, ?)`
		workDiagramImageQuery := `INSERT INTO work_diagram_images (work_id, image_id, created_at, updated_at) VALUES (?, ?, ?, ?)`

		for _, diagramImageUrl := range input.DiagramImageURL {
			diagramImageUID, _ := uuid.NewRandom()
			diagramImageID := diagramImageUID.String()

			if _, err := tx.ExecContext(ctx, diagramImageQuery, diagramImageID, diagramImageUrl, now, now); err != nil {
				log.Printf("Error inserting diagram image with transaction: %v", err)

				return nil, &gqlerror.Error{
					Message: "図の画像の登録に失敗しました。",
					Extensions: map[string]interface{}{
						"code": "INTERNAL_SERVER_ERROR",
					},
				}
			}

			if _, err := tx.ExecContext(ctx, workDiagramImageQuery, work.ID, diagramImageID, now, now); err != nil {
				log.Printf("Error inserting work_diagram_image relation with transaction: %v", err)

				return nil, &gqlerror.Error{
					Message: "失敗しました。",
					Extensions: map[string]interface{}{
						"code": "INTERNAL_SERVER_ERROR",
					},
				}
			}
		}
	}

	if len(input.Skills) > 0 {
		skillQuery := `INSERT INTO work_skills (work_id, skill_id, created_at, updated_at) VALUES (?, ?, ?, ?)`
		for _, skillID := range input.Skills {
			if _, err := tx.ExecContext(ctx, skillQuery, work.ID, skillID, now, now); err != nil {
				log.Printf("Error inserting work_skill with transaction: %v", err)

				return nil, &gqlerror.Error{
					Message: "スキルの登録に失敗しました。",
					Extensions: map[string]interface{}{
						"code": "INTERNAL_SERVER_ERROR",
					},
				}
			}
		}
	}

	if len(input.UserIds) > 0 {
		profileQuery := `INSERT INTO work_profiles (work_id, profile_id, created_at, updated_at) VALUES (?, ?, ?, ?)`
		for _, userID := range input.UserIds {
			if _, err := tx.ExecContext(ctx, profileQuery, work.ID, userID, now, now); err != nil {
				log.Printf("Error inserting work_profile with transaction: %v", err)

				return nil, &gqlerror.Error{
					Message: "ユーザーの登録に失敗しました。",
					Extensions: map[string]interface{}{
						"code": "INTERNAL_SERVER_ERROR",
					},
				}
			}
		}
	}

	if err := tx.Commit(); err != nil {
		log.Printf("Error committing transaction: %v", err)

		return nil, &gqlerror.Error{
			Message: "作品の登録に失敗しました。",
			Extensions: map[string]interface{}{
				"code": "INTERNAL_SERVER_ERROR",
			},
		}
	}

	return work, nil
}

// CreateProjectEvent is the resolver for the createProjectEvent field.
func (r *mutationResolver) CreateProjectEvent(ctx context.Context, input model.NewCreateProjectEvent) (respWork *model.Work, err error) {
	now := time.Now()
	var workID string

	tx, err := r.DB.BeginTx(ctx, nil)
	if err != nil {
		log.Printf("Error beginning transaction: %v", err)

		return nil, &gqlerror.Error{
			Message: "プロジェクトイベントの作成に失敗しました。",
			Extensions: map[string]interface{}{
				"code": "INTERNAL_SERVER_ERROR",
			},
		}
	}
	defer func() {
		if p := recover(); p != nil {
			log.Printf("Panic recovered, rolling back: %v", p)
			tx.Rollback()
			panic(p)
		} else if err != nil {
			log.Printf("Error occurred [%v], rolling back.", err)
			if rbErr := tx.Rollback(); rbErr != nil {
				log.Printf("Error during deferred rollback: %v", rbErr)
			}
		} else {
		}
	}()

	respWork = &model.Work{
		Title:       input.Title,
		Description: input.Description,
		CreatedAt:   now,
		UpdatedAt:   now,
		EventID:     input.EventID,
		UserIDs:     input.UserIds,
	}

	if input.WorkID == nil {
		uid, _ := uuid.NewRandom()
		workID = uid.String()
		respWork.ID = workID

		log.Printf("Attempting to insert new work: %s", workID)
		query := `
      INSERT INTO works (id, title, description, created_at, updated_at)
      VALUES (?, ?, ?, ?, ?)
    `
		if _, execErr := tx.ExecContext(ctx, query, respWork.ID, respWork.Title, respWork.Description, respWork.CreatedAt, respWork.UpdatedAt); execErr != nil {
			log.Printf("Error inserting new work: %v", execErr)

			return nil, &gqlerror.Error{
				Message: "作品の登録に失敗しました。",
				Extensions: map[string]interface{}{
					"code": "INTERNAL_SERVER_ERROR",
				},
			}
		}

		if input.ImageURL != nil {
			imageQuery := `INSERT INTO images (id, image_url, created_at, updated_at) VALUES (?, ?, ?, ?)`
			workImageQuery := `INSERT INTO work_images (work_id, image_id, created_at, updated_at) VALUES (?, ?, ?, ?)`

			for _, imageUrl := range input.ImageURL {
				imageUID, _ := uuid.NewRandom()
				imageID := imageUID.String()

				if _, err := tx.ExecContext(ctx, imageQuery, imageID, imageUrl, now, now); err != nil {
					log.Printf("Error inserting image: %v", err)

					return nil, &gqlerror.Error{
						Message: "画像の登録に失敗しました。",
						Extensions: map[string]interface{}{
							"code": "INTERNAL_SERVER_ERROR",
						},
					}
				}

				if _, err := tx.ExecContext(ctx, workImageQuery, workID, imageID, now, now); err != nil {
					log.Printf("Error inserting work_image relation: %v", err)

					return nil, &gqlerror.Error{
						Message: "失敗しました。",
						Extensions: map[string]interface{}{
							"code": "INTERNAL_SERVER_ERROR",
						},
					}
				}
			}
		}

		if input.DiagramImageURL != nil {
			diagramImageQuery := `INSERT INTO diagram_images (id, image_url, created_at, updated_at) VALUES (?, ?, ?, ?)`
			workDiagramImageQuery := `INSERT INTO work_diagram_images (work_id, image_id, created_at, updated_at) VALUES (?, ?, ?, ?)`

			for _, diagramImageUrl := range input.DiagramImageURL {
				diagramImageUID, _ := uuid.NewRandom()
				diagramImageID := diagramImageUID.String()

				if _, err := tx.ExecContext(ctx, diagramImageQuery, diagramImageID, diagramImageUrl, now, now); err != nil {
					log.Printf("Error inserting diagram image: %v", err)

					return nil, &gqlerror.Error{
						Message: "図の画像の登録に失敗しました。",
						Extensions: map[string]interface{}{
							"code": "INTERNAL_SERVER_ERROR",
						},
					}
				}

				if _, err := tx.ExecContext(ctx, workDiagramImageQuery, workID, diagramImageID, now, now); err != nil {
					log.Printf("Error inserting work_diagram_image relation: %v", err)

					return nil, &gqlerror.Error{
						Message: "失敗しました。",
						Extensions: map[string]interface{}{
							"code": "INTERNAL_SERVER_ERROR",
						},
					}
				}
			}
		}

		if len(input.Skills) > 0 {
			skillQuery := `INSERT INTO work_skills (work_id, skill_id, created_at, updated_at) VALUES (?, ?, ?, ?)`
			for _, skillID := range input.Skills {
				if _, execErr := tx.ExecContext(ctx, skillQuery, workID, skillID, now, now); execErr != nil {
					log.Printf("Error inserting work_skill for new work: %v", execErr)

					return nil, &gqlerror.Error{
						Message: "スキルの登録に失敗しました。",
						Extensions: map[string]interface{}{
							"code": "INTERNAL_SERVER_ERROR",
						},
					}
				}
			}
			log.Printf("Successfully inserted work_skills for work: %s", workID)
		}

		if len(input.UserIds) > 0 {
			profileQuery := `INSERT INTO work_profiles (work_id, profile_id, created_at, updated_at) VALUES (?, ?, ?, ?)`
			for _, userID := range input.UserIds {
				if _, execErr := tx.ExecContext(ctx, profileQuery, workID, userID, now, now); execErr != nil {
					log.Printf("Error inserting work_profile for new work: %v", execErr)

					return nil, &gqlerror.Error{
						Message: "ユーザーの登録に失敗しました。",
						Extensions: map[string]interface{}{
							"code": "INTERNAL_SERVER_ERROR",
						},
					}
				}
			}
			log.Printf("Successfully inserted work_profiles for work: %s", workID)
		}

		if input.EventID != nil {
			eventQuery := `INSERT INTO work_events (work_id, event_id, created_at, updated_at) VALUES (?, ?, ?, ?)`
			if _, execErr := tx.ExecContext(ctx, eventQuery, workID, *input.EventID, now, now); execErr != nil {
				err = fmt.Errorf("failed to insert work_event for new work %s: %w", workID, execErr)
				log.Printf("Error: %v", err)

				return nil, &gqlerror.Error{
					Message: "イベントの登録に失敗しました。",
					Extensions: map[string]interface{}{
						"code": "INTERNAL_SERVER_ERROR",
					},
				}
			}
			log.Printf("Successfully inserted work_event for work: %s", workID)
		}
	} else {
		workID = *input.WorkID
		respWork.ID = workID

		if input.EventID == nil {
			log.Printf("No EventID provided for existing work: %s", workID)

			return nil, &gqlerror.Error{
				Message: "イベントが提供されていません。",
				Extensions: map[string]interface{}{
					"code": "BAD_USER_INPUT",
				},
			}
		}

		eventQuery := `INSERT INTO work_events (work_id, event_id, created_at, updated_at) VALUES (?, ?, ?, ?)`
		if _, execErr := tx.ExecContext(ctx, eventQuery, workID, *input.EventID, now, now); execErr != nil {
			err = fmt.Errorf("failed to insert work_event for existing work %s: %w", workID, execErr)
			log.Printf("Error: %v", err)

			return nil, &gqlerror.Error{
				Message: "イベントの登録に失敗しました。",
				Extensions: map[string]interface{}{
					"code": "INTERNAL_SERVER_ERROR",
				},
			}
		}
	}

	if commitErr := tx.Commit(); commitErr != nil {
		log.Printf("Error committing transaction: %v", commitErr)

		return nil, &gqlerror.Error{
			Message: "プロジェクトイベントの作成に失敗しました。",
			Extensions: map[string]interface{}{
				"code": "INTERNAL_SERVER_ERROR",
			},
		}
	}

	return respWork, nil
}

// UpdateWork is the resolver for the updateWork field.
func (r *mutationResolver) UpdateWork(ctx context.Context, id string, input model.UpdateWork) (*model.Work, error) {
	tx, err := r.DB.BeginTx(ctx, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}

	defer func() {
		// このdeferブロックは、err変数がnilでない場合に自動的にロールバックします
		if err != nil {
			tx.Rollback()
			log.Printf("Transaction rolled back due to error: %v", err)
		}
	}()

	// --- 1. メインテーブル `works` の更新 ---
	now := time.Now()
	var args []interface{}
	var setClauses []string

	if input.Title != nil {
		setClauses = append(setClauses, "title = ?")
		args = append(args, *input.Title)
	}
	if input.Description != nil {
		setClauses = append(setClauses, "description = ?")
		args = append(args, *input.Description)
	}

	if len(setClauses) > 0 {
		setClauses = append(setClauses, "updated_at = ?")
		args = append(args, now, id)
		updateQuery := fmt.Sprintf("UPDATE works SET %s WHERE id = ?", strings.Join(setClauses, ", "))
		var result sql.Result
		result, err = tx.ExecContext(ctx, updateQuery, args...)
		if err != nil {
			return nil, &gqlerror.Error{Message: "作品の更新に失敗しました。"}
		}
		rowsAffected, _ := result.RowsAffected()
		if rowsAffected == 0 {
			err = fmt.Errorf("work with id %s not found", id) // エラーをセットしてdeferにロールバックさせる
			return nil, &gqlerror.Error{Message: fmt.Sprintf("ID '%s' の作品が見つかりません。", id), Extensions: map[string]interface{}{"code": "NOT_FOUND"}}
		}
	}

	// --- 2. 関連データの更新 ---
	if input.ImageURL != nil {
		if err = util.SyncImages(ctx, tx, id, input.ImageURL, "images", "work_images", "image_id"); err != nil {
			return nil, &gqlerror.Error{Message: "作品画像の更新に失敗しました。"}
		}
	}
	if input.DiagramImageURL != nil {
		if err = util.SyncImages(ctx, tx, id, input.DiagramImageURL, "diagram_images", "work_diagram_images", "image_id"); err != nil {
			return nil, &gqlerror.Error{Message: "構成図の更新に失敗しました。"}
		}
	}
	if input.UserIds != nil {
		if err = util.SyncRelatedRecords(ctx, tx, id, input.UserIds, "work_profiles", "work_id", "profile_id"); err != nil {
			return nil, &gqlerror.Error{Message: "共同制作者の更新に失敗しました。"}
		}
	}
	if input.Skills != nil {
		if err = util.SyncRelatedRecords(ctx, tx, id, input.Skills, "work_skills", "work_id", "skill_id"); err != nil {
			return nil, &gqlerror.Error{Message: "技術スタックの更新に失敗しました。"}
		}
	}

	if err = tx.Commit(); err != nil {
		log.Printf("Error committing transaction: %v", err)
		return nil, &gqlerror.Error{Message: "作品の更新を完了できませんでした。"}
	}

	// 更新後の完全なデータを取得して返す
	return r.Query().Work(ctx, id)
}

// Work is the resolver for the work field.
func (r *queryResolver) Work(ctx context.Context, id string) (*model.Work, error) {
	query := `
		SELECT id, title, description, created_at, updated_at
		FROM works
		WHERE id = ?
	`
	work := &model.Work{}
	var eventID sql.NullString
	if err := r.DB.QueryRowContext(ctx, query, id).Scan(&work.ID, &work.Title, &work.Description, &work.CreatedAt, &work.UpdatedAt); err != nil {
		if err == sql.ErrNoRows {
			log.Printf("Work with ID %s not found", id)

			return nil, &gqlerror.Error{
				Message: "作品が見つかりません。",
				Extensions: map[string]interface{}{
					"code": "NOT_FOUND",
				},
			}
		}
		return nil, err
	}
	if eventID.Valid {
		work.EventID = &eventID.String
	}

	var userIDs []string
	profileQuery := `SELECT profile_id FROM work_profiles WHERE work_id = ?`
	profileRows, err := r.DB.QueryContext(ctx, profileQuery, work.ID)
	if err != nil {
		log.Printf("Error querying work_profiles for work ID %s: %v", work.ID, err)

		return nil, &gqlerror.Error{
			Message: "ユーザーの取得に失敗しました。",
			Extensions: map[string]interface{}{
				"code": "INTERNAL_SERVER_ERROR",
			},
		}
	}
	defer profileRows.Close()
	for profileRows.Next() {
		var userID string
		if err := profileRows.Scan(&userID); err != nil {
			log.Printf("Error scanning profile_id for work ID %s: %v", work.ID, err)

			return nil, &gqlerror.Error{
				Message: "ユーザーの取得中にサーバーエラーが発生しました。",
				Extensions: map[string]interface{}{
					"code": "INTERNAL_SERVER_ERROR",
				},
			}
		}
		userIDs = append(userIDs, userID)
	}
	work.UserIDs = userIDs

	imageQuery := `
		SELECT i.id, i.image_url
		FROM images i
		JOIN work_images wi ON i.id = wi.image_id
		WHERE wi.work_id = ?
	`
	imageRows, err := r.DB.QueryContext(ctx, imageQuery, work.ID)
	if err != nil {
		log.Printf("Error querying work_images for work ID %s: %v", work.ID, err)

		return nil, &gqlerror.Error{
			Message: "画像の取得に失敗しました。",
			Extensions: map[string]interface{}{
				"code": "INTERNAL_SERVER_ERROR",
			},
		}
	}
	defer imageRows.Close()
	var images []*model.Image
	for imageRows.Next() {
		image := &model.Image{}
		if err := imageRows.Scan(&image.ID, &image.ImageURL); err != nil {
			log.Printf("Error scanning image for work ID %s: %v", work.ID, err)

			return nil, &gqlerror.Error{
				Message: "画像の取得中にサーバーエラーが発生しました。",
				Extensions: map[string]interface{}{
					"code": "INTERNAL_SERVER_ERROR",
				},
			}
		}
		images = append(images, image)
	}
	if len(images) > 0 {
		work.ImageID = make([]string, len(images))
		for i, img := range images {
			work.ImageID[i] = img.ID
		}
		work.Images = images
	} else {
		work.Images = []*model.Image{}
		work.ImageID = []string{}
	}

	diagramImageQuery := `
		SELECT di.id, di.image_url
		FROM diagram_images di
		JOIN work_diagram_images wdi ON di.id = wdi.image_id
		WHERE wdi.work_id = ?
	`
	diagramImageRows, err := r.DB.QueryContext(ctx, diagramImageQuery, work.ID)
	if err != nil {
		log.Printf("Error querying work_diagram_images for work ID %s: %v", work.ID, err)

		return nil, &gqlerror.Error{
			Message: "図の画像の取得に失敗しました。",
			Extensions: map[string]interface{}{
				"code": "INTERNAL_SERVER_ERROR",
			},
		}
	}
	defer diagramImageRows.Close()
	var diagramImages []*model.DiagramImage
	for diagramImageRows.Next() {
		diagramImage := &model.DiagramImage{}
		if err := diagramImageRows.Scan(&diagramImage.ID, &diagramImage.ImageURL); err != nil {
			log.Printf("Error scanning diagram image for work ID %s: %v", work.ID, err)

			return nil, &gqlerror.Error{
				Message: "図の画像の取得中にサーバーエラーが発生しました。",
				Extensions: map[string]interface{}{
					"code": "INTERNAL_SERVER_ERROR",
				},
			}
		}
		diagramImages = append(diagramImages, diagramImage)
	}
	if len(diagramImages) > 0 {
		diagramImageURLs := make([]*string, len(diagramImages))
		for i, di := range diagramImages {
			diagramImageURLs[i] = &di.ImageURL
		}
		work.DiagramImageID = diagramImageURLs
		work.DiagramImages = diagramImages
	} else {
		work.DiagramImages = []*model.DiagramImage{}
		work.DiagramImageID = []*string{}
	}

	eventQuery := `
		SELECT e.id, e.name
		FROM events e
		JOIN work_events we ON e.id = we.event_id
		WHERE we.work_id = ?
	`
	eventRows, err := r.DB.QueryContext(ctx, eventQuery, work.ID)
	if err != nil {
		log.Printf("Error querying work_events for work ID %s: %v", work.ID, err)

		return nil, &gqlerror.Error{
			Message: "イベントの取得に失敗しました。",
			Extensions: map[string]interface{}{
				"code": "INTERNAL_SERVER_ERROR",
			},
		}
	}
	defer eventRows.Close()
	var events []*model.Event
	for eventRows.Next() {
		event := &model.Event{}
		if err := eventRows.Scan(&event.ID, &event.Name); err != nil {
			log.Printf("Error scanning event for work ID %s: %v", work.ID, err)

			return nil, &gqlerror.Error{
				Message: "イベントの取得中にサーバーエラーが発生しました。",
				Extensions: map[string]interface{}{
					"code": "INTERNAL_SERVER_ERROR",
				},
			}
		}
		events = append(events, event)
	}
	if len(events) > 0 {
		work.Events = events
	} else {
		work.Events = []*model.Event{}
	}

	profileObjQuery := `
		SELECT p.id, p.avatar_url, p.nick_name
		FROM profiles p
		JOIN work_profiles wp ON p.id = wp.profile_id
		WHERE wp.work_id = ?
	`
	profileObjRows, err := r.DB.QueryContext(ctx, profileObjQuery, work.ID)
	if err != nil {
		log.Printf("Error querying work_profiles for work ID %s: %v", work.ID, err)

		return nil, &gqlerror.Error{
			Message: "ユーザーの取得に失敗しました。",
			Extensions: map[string]interface{}{
				"code": "INTERNAL_SERVER_ERROR",
			},
		}
	}
	defer profileObjRows.Close()
	var profiles []model.Profile
	for profileObjRows.Next() {
		profile := model.Profile{}
		if err := profileObjRows.Scan(&profile.ID, &profile.AvatarURL, &profile.NickName); err != nil {
			log.Printf("Error scanning profile for work ID %s: %v", work.ID, err)

			return nil, &gqlerror.Error{
				Message: "ユーザーの取得中にサーバーエラーが発生しました。",
				Extensions: map[string]interface{}{
					"code": "INTERNAL_SERVER_ERROR",
				},
			}
		}
		profiles = append(profiles, profile)
	}
	if len(profiles) > 0 {
		work.Profiles = profiles
	} else {
		work.Profiles = []model.Profile{}
	}

	skillQuery := `
		SELECT s.id, s.name
		FROM skills s
		JOIN work_skills ws ON s.id = ws.skill_id
		WHERE ws.work_id = ?
	`
	skillRows, err := r.DB.QueryContext(ctx, skillQuery, work.ID)
	if err != nil {
		log.Printf("Error querying work_skills for work ID %s: %v", work.ID, err)

		return nil, &gqlerror.Error{
			Message: "スキルの取得に失敗しました。",
			Extensions: map[string]interface{}{
				"code": "INTERNAL_SERVER_ERROR",
			},
		}
	}
	defer skillRows.Close()
	var skills []model.Skill
	for skillRows.Next() {
		skill := model.Skill{}
		if err := skillRows.Scan(&skill.ID, &skill.Name); err != nil {
			log.Printf("Error scanning skill for work ID %s: %v", work.ID, err)

			return nil, &gqlerror.Error{
				Message: "スキルの取得中にサーバーエラーが発生しました。",
				Extensions: map[string]interface{}{
					"code": "INTERNAL_SERVER_ERROR",
				},
			}
		}
		skills = append(skills, skill)
	}
	if len(skills) > 0 {
		work.Skills = skills
	} else {
		work.Skills = []model.Skill{}
	}

	return work, nil
}

// WorksByTitle is the resolver for the worksByTitle field.
func (r *queryResolver) WorksByTitle(ctx context.Context, title string) ([]*model.Work, error) {
	query := `
		SELECT id, title, description, created_at, updated_at, event_id
		FROM works
		WHERE title = ?
	`
	baseRows, err := r.DB.QueryContext(ctx, query, title)
	if err != nil {
		log.Printf("Error querying works by title '%s': %v", title, err)

		return nil, &gqlerror.Error{
			Message: "作品の取得に失敗しました。",
			Extensions: map[string]interface{}{
				"code": "INTERNAL_SERVER_ERROR",
			},
		}
	}
	defer baseRows.Close()

	var works []*model.Work
	for baseRows.Next() {
		work := &model.Work{}
		var eventID sql.NullString
		if err := baseRows.Scan(&work.ID, &work.Title, &work.Description, &work.CreatedAt, &work.UpdatedAt, &eventID); err != nil {
			log.Printf("Error scanning work by title '%s': %v", title, err)

			return nil, &gqlerror.Error{
				Message: "作品の取得中にサーバーエラーが発生しました。",
				Extensions: map[string]interface{}{
					"code": "INTERNAL_SERVER_ERROR",
				},
			}
		}
		if eventID.Valid {
			work.EventID = &eventID.String
		}

		imageQuery := `
			SELECT i.id, i.image_url
			FROM images i
			JOIN work_images wi ON i.id = wi.image_id
			WHERE wi.work_id = ?
		`
		imageRows, err := r.DB.QueryContext(ctx, imageQuery, work.ID)
		if err != nil {
			log.Printf("Error querying work_images for work ID %s: %v", work.ID, err)

			return nil, &gqlerror.Error{
				Message: "画像の取得に失敗しました。",
				Extensions: map[string]interface{}{
					"code": "INTERNAL_SERVER_ERROR",
				},
			}
		}
		defer imageRows.Close()
		var images []*model.Image
		for imageRows.Next() {
			image := &model.Image{}
			if err := imageRows.Scan(&image.ID, &image.ImageURL); err != nil {
				log.Printf("Error scanning image for work ID %s: %v", work.ID, err)

				return nil, &gqlerror.Error{
					Message: "画像の取得中にサーバーエラーが発生しました。",
					Extensions: map[string]interface{}{
						"code": "INTERNAL_SERVER_ERROR",
					},
				}
			}
			images = append(images, image)
		}
		if len(images) > 0 {
			work.ImageID = make([]string, len(images))
			for i, img := range images {
				work.ImageID[i] = img.ID
			}
			work.Images = images
		} else {
			work.Images = []*model.Image{}
			work.ImageID = []string{}
		}

		diagramImageQuery := `
			SELECT di.id, di.image_url
			FROM diagram_images di
			JOIN work_diagram_images wdi ON di.id = wdi.image_id
			WHERE wdi.work_id = ?
		`
		diagramImageRows, err := r.DB.QueryContext(ctx, diagramImageQuery, work.ID)
		if err != nil {
			log.Printf("Error querying work_diagram_images for work ID %s: %v", work.ID, err)

			return nil, &gqlerror.Error{
				Message: "図の画像の取得に失敗しました。",
				Extensions: map[string]interface{}{
					"code": "INTERNAL_SERVER_ERROR",
				},
			}
		}
		defer diagramImageRows.Close()
		var diagramImages []*model.DiagramImage
		for diagramImageRows.Next() {
			diagramImage := &model.DiagramImage{}
			if err := diagramImageRows.Scan(&diagramImage.ID, &diagramImage.ImageURL); err != nil {
				log.Printf("Error scanning diagram image for work ID %s: %v", work.ID, err)

				return nil, &gqlerror.Error{
					Message: "図の画像の取得中にサーバーエラーが発生しました。",
					Extensions: map[string]interface{}{
						"code": "INTERNAL_SERVER_ERROR",
					},
				}
			}
			diagramImages = append(diagramImages, diagramImage)
		}
		if len(diagramImages) > 0 {
			diagramImageURLs := make([]*string, len(diagramImages))
			for i, di := range diagramImages {
				diagramImageURLs[i] = &di.ImageURL
			}
			work.DiagramImageID = diagramImageURLs
			work.DiagramImages = diagramImages
		} else {
			work.DiagramImages = []*model.DiagramImage{}
			work.DiagramImageID = []*string{}
		}

		works = append(works, work)
	}

	return works, nil
}

// WorkList is the resolver for the workList field.
func (r *queryResolver) WorkList(ctx context.Context, first *int32, after *string, last *int32, before *string) (*model.WorkConnection, error) {
	limit := 3
	forward := true

	if first != nil {
		limit = int(*first)
		forward = true
	} else if last != nil {
		limit = int(*last)
		forward = false
	}

	var afterCurs, beforeCurs *model.Cursor
	var err error

	if after != nil && *after != "" {
		log.Printf("Received after cursor: %s", *after)
		afterCurs, err = model.DecodeCursor(*after)
		if err != nil {
			log.Printf("Error decoding after cursor: %v", err)

			return nil, &gqlerror.Error{
				Message: "無効なafterカーソルです。",
				Extensions: map[string]interface{}{
					"code": "INTERNAL_SERVER_ERROR",
				},
			}
		}
	}

	if before != nil && *before != "" {
		beforeCurs, err = model.DecodeCursor(*before)
		if err != nil {
			log.Printf("Error decoding before cursor: %v", err)

			return nil, &gqlerror.Error{
				Message: "無効なbeforeカーソルです。",
				Extensions: map[string]interface{}{
					"code": "INTERNAL_SERVER_ERROR",
				},
			}
		} else {
			log.Printf("Received before cursor: %s", *before)
		}
	}

	orderDirection := "DESC"
	comparisonOp1 := "<"
	comparisonOp2 := "<"
	if !forward {
		orderDirection = "ASC"
		comparisonOp1 = ">"
		comparisonOp2 = ">"
	}

	whereConditions := []string{}
	args := []interface{}{}

	if forward && afterCurs != nil {
		whereConditions = append(whereConditions,
			fmt.Sprintf("(created_at %s ? OR (created_at = ? AND id %s ?))", comparisonOp1, comparisonOp2),
		)
		args = append(args, afterCurs.CreatedAt, afterCurs.CreatedAt, afterCurs.ID)
	} else if !forward && beforeCurs != nil {
		whereConditions = append(whereConditions,
			fmt.Sprintf("(created_at %s ? OR (created_at = ? AND id %s ?))", comparisonOp1, comparisonOp2),
		)
		args = append(args, beforeCurs.CreatedAt, beforeCurs.CreatedAt, beforeCurs.ID)
	}

	whereClause := ""
	if len(whereConditions) > 0 {
		whereClause = "WHERE " + strings.Join(whereConditions, " AND ")
	}

	query := fmt.Sprintf(`
		SELECT id, title, description, created_at, updated_at
		FROM works
		%s
		ORDER BY created_at %s, id %s
		LIMIT ?
	`, whereClause, orderDirection, orderDirection)

	args = append(args, limit+1)

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		log.Printf("Error querying work list: %v", err)

		return nil, &gqlerror.Error{
			Message: "作品の取得に失敗しました。",
			Extensions: map[string]interface{}{
				"code": "INTERNAL_SERVER_ERROR",
			},
		}
	}
	defer rows.Close()

	works := []*model.Work{}
	for rows.Next() {
		w := &model.Work{}
		if err := rows.Scan(&w.ID, &w.Title, &w.Description, &w.CreatedAt, &w.UpdatedAt); err != nil {
			rows.Close()
			log.Printf("Error scanning work: %v", err)

			return nil, &gqlerror.Error{
				Message: "作品の取得中にサーバーエラーが発生しました。",
				Extensions: map[string]interface{}{
					"code": "INTERNAL_SERVER_ERROR",
				},
			}
		}
		works = append(works, w)
	}
	if err = rows.Err(); err != nil {
		log.Printf("Error during work list rows iteration: %v", err)

		return nil, &gqlerror.Error{
			Message: "作品の取得中にサーバーエラーが発生しました。",
			Extensions: map[string]interface{}{
				"code": "INTERNAL_SERVER_ERROR",
			},
		}
	}

	if len(works) > 0 {
		workIDs := make([]string, 0, len(works))
		for _, w := range works {
			workIDs = append(workIDs, w.ID)
			w.Events = []*model.Event{}
			w.Profiles = []model.Profile{}
			w.Skills = []model.Skill{}
			w.UserIDs = []string{}
			w.Images = []*model.Image{}
			w.DiagramImages = []*model.DiagramImage{}
		}

		placeholders := make([]string, len(workIDs))
		idArgs := make([]interface{}, len(workIDs))
		for i, id := range workIDs {
			placeholders[i] = "?"
			idArgs[i] = id
		}
		inClause := strings.Join(placeholders, ",")

		userIDsQuery := fmt.Sprintf(`SELECT work_id, profile_id FROM work_profiles WHERE work_id IN (%s)`, inClause)
		userIDRows, err := r.DB.QueryContext(ctx, userIDsQuery, idArgs...)
		if err != nil {
			log.Printf("Error querying user IDs for work list: %v", err)

			return nil, &gqlerror.Error{
				Message: "ユーザーの取得に失敗しました。",
				Extensions: map[string]interface{}{
					"code": "INTERNAL_SERVER_ERROR",
				},
			}
		}
		userIDsByWorkID := make(map[string][]string)
		for userIDRows.Next() {
			var workID, userID string
			if err := userIDRows.Scan(&workID, &userID); err != nil {
				userIDRows.Close()
				log.Printf("Error scanning user ID for work list: %v", err)

				return nil, &gqlerror.Error{
					Message: "ユーザーの取得中にサーバーエラーが発生しました。",
					Extensions: map[string]interface{}{
						"code": "INTERNAL_SERVER_ERROR",
					},
				}
			}
			userIDsByWorkID[workID] = append(userIDsByWorkID[workID], userID)
		}
		userIDRows.Close()
		if err = userIDRows.Err(); err != nil {
			log.Printf("Error during userIDRows iteration: %v", err)

			return nil, &gqlerror.Error{
				Message: "ユーザーの取得中にサーバーエラーが発生しました。",
				Extensions: map[string]interface{}{
					"code": "INTERNAL_SERVER_ERROR",
				},
			}
		}

		eventQuery := fmt.Sprintf(`
			SELECT we.work_id, e.id, e.name
			FROM events e
			JOIN work_events we ON e.id = we.event_id
			WHERE we.work_id IN (%s)`, inClause)
		eventRows, err := r.DB.QueryContext(ctx, eventQuery, idArgs...)
		if err != nil {
			log.Printf("Error querying events for work list: %v", err)

			return nil, &gqlerror.Error{
				Message: "イベントの取得に失敗しました。",
				Extensions: map[string]interface{}{
					"code": "INTERNAL_SERVER_ERROR",
				},
			}
		}
		eventsByWorkID := make(map[string][]*model.Event)
		for eventRows.Next() {
			var workID string
			event := &model.Event{}
			if err := eventRows.Scan(&workID, &event.ID, &event.Name); err != nil {
				eventRows.Close()
				log.Printf("Error scanning event for work list: %v", err)

				return nil, &gqlerror.Error{
					Message: "イベントの取得中にサーバーエラーが発生しました。",
					Extensions: map[string]interface{}{
						"code": "INTERNAL_SERVER_ERROR",
					},
				}
			}
			eventsByWorkID[workID] = append(eventsByWorkID[workID], event)
		}
		eventRows.Close()
		if err = eventRows.Err(); err != nil {
			log.Printf("Error during eventRows iteration: %v", err)

			return nil, &gqlerror.Error{
				Message: "イベントの取得中にサーバーエラーが発生しました。",
				Extensions: map[string]interface{}{
					"code": "INTERNAL_SERVER_ERROR",
				},
			}
		}

		profileQuery := fmt.Sprintf(`
			SELECT wp.work_id, p.id, p.avatar_url, p.nick_name
			FROM profiles p
			JOIN work_profiles wp ON p.id = wp.profile_id
			WHERE wp.work_id IN (%s)`, inClause)
		profileRows, err := r.DB.QueryContext(ctx, profileQuery, idArgs...)
		if err != nil {
			log.Printf("Error querying profiles for work list: %v", err)

			return nil, &gqlerror.Error{
				Message: "ユーザーの取得に失敗しました。",
				Extensions: map[string]interface{}{
					"code": "INTERNAL_SERVER_ERROR",
				},
			}
		}
		profilesByWorkID := make(map[string][]model.Profile)
		for profileRows.Next() {
			var workID string
			profile := model.Profile{}
			if err := profileRows.Scan(&workID, &profile.ID, &profile.AvatarURL, &profile.NickName); err != nil {
				profileRows.Close()
				log.Printf("Error scanning profile for work list: %v", err)

				return nil, &gqlerror.Error{
					Message: "ユーザーの取得中にサーバーエラーが発生しました。",
					Extensions: map[string]interface{}{
						"code": "INTERNAL_SERVER_ERROR",
					},
				}
			}
			profilesByWorkID[workID] = append(profilesByWorkID[workID], profile)
		}
		profileRows.Close()
		if err = profileRows.Err(); err != nil {
			log.Printf("Error during profileRows iteration: %v", err)

			return nil, &gqlerror.Error{
				Message: "ユーザーの取得中にサーバーエラーが発生しました。",
				Extensions: map[string]interface{}{
					"code": "INTERNAL_SERVER_ERROR",
				},
			}
		}

		skillQuery := fmt.Sprintf(`
			SELECT ws.work_id, s.id, s.name
			FROM skills s
			JOIN work_skills ws ON s.id = ws.skill_id
			WHERE ws.work_id IN (%s)`, inClause)
		skillRows, err := r.DB.QueryContext(ctx, skillQuery, idArgs...)
		if err != nil {
			log.Printf("Error querying skills for work list: %v", err)

			return nil, &gqlerror.Error{
				Message: "スキルの取得に失敗しました。",
				Extensions: map[string]interface{}{
					"code": "INTERNAL_SERVER_ERROR",
				},
			}
		}
		skillsByWorkID := make(map[string][]model.Skill)
		for skillRows.Next() {
			var workID string
			skill := model.Skill{}
			if err := skillRows.Scan(&workID, &skill.ID, &skill.Name); err != nil {
				skillRows.Close()
				log.Printf("Error scanning skill for work list: %v", err)

				return nil, &gqlerror.Error{
					Message: "スキルの取得中にサーバーエラーが発生しました。",
					Extensions: map[string]interface{}{
						"code": "INTERNAL_SERVER_ERROR",
					},
				}
			}
			skillsByWorkID[workID] = append(skillsByWorkID[workID], skill)
		}
		skillRows.Close()
		if err = skillRows.Err(); err != nil {
			log.Printf("Error during skillRows iteration: %v", err)

			return nil, &gqlerror.Error{
				Message: "スキルの取得中にサーバーエラーが発生しました。",
				Extensions: map[string]interface{}{
					"code": "INTERNAL_SERVER_ERROR",
				},
			}
		}

		// 画像と図表画像も取得
		imageMap := make(map[string][]*model.Image)
		imageIDsQuery := fmt.Sprintf(`
			SELECT wi.work_id, i.id, i.image_url
			FROM images i
			JOIN work_images wi ON i.id = wi.image_id
			WHERE wi.work_id IN (%s)`, inClause)
		imageRows, err := r.DB.QueryContext(ctx, imageIDsQuery, idArgs...)
		if err != nil {
			log.Printf("Error querying images for work list: %v", err)

			return nil, &gqlerror.Error{
				Message: "画像の取得に失敗しました。",
				Extensions: map[string]interface{}{
					"code": "INTERNAL_SERVER_ERROR",
				},
			}
		}
		for imageRows.Next() {
			var workID string
			img := &model.Image{}
			if err := imageRows.Scan(&workID, &img.ID, &img.ImageURL); err != nil {
				imageRows.Close()
				log.Printf("Error scanning image for work list: %v", err)

				return nil, &gqlerror.Error{
					Message: "画像の取得中にサーバーエラーが発生しました。",
					Extensions: map[string]interface{}{
						"code": "INTERNAL_SERVER_ERROR",
					},
				}
			}
			imageMap[workID] = append(imageMap[workID], img)
		}
		imageRows.Close()

		diagramImageMap := make(map[string][]*model.DiagramImage)
		diagramImageIDsQuery := fmt.Sprintf(`
			SELECT wdi.work_id, di.id, di.image_url
			FROM diagram_images di
			JOIN work_diagram_images wdi ON di.id = wdi.image_id
			WHERE wdi.work_id IN (%s)`, inClause)
		diagramImageRows, err := r.DB.QueryContext(ctx, diagramImageIDsQuery, idArgs...)
		if err != nil {
			log.Printf("Error querying diagram images for work list: %v", err)

			return nil, &gqlerror.Error{
				Message: "図の画像の取得に失敗しました。",
				Extensions: map[string]interface{}{
					"code": "INTERNAL_SERVER_ERROR",
				},
			}

		}
		for diagramImageRows.Next() {
			var workID string
			diagImg := &model.DiagramImage{}
			if err := diagramImageRows.Scan(&workID, &diagImg.ID, &diagImg.ImageURL); err != nil {
				diagramImageRows.Close()
				log.Printf("Error scanning diagram image for work list: %v", err)

				return nil, &gqlerror.Error{
					Message: "図の画像の取得中にサーバーエラーが発生しました。",
					Extensions: map[string]interface{}{
						"code": "INTERNAL_SERVER_ERROR",
					},
				}
			}
			diagramImageMap[workID] = append(diagramImageMap[workID], diagImg)
		}
		diagramImageRows.Close()

		for _, work := range works {
			if ids, ok := userIDsByWorkID[work.ID]; ok {
				work.UserIDs = ids
			}
			if evts, ok := eventsByWorkID[work.ID]; ok {
				work.Events = evts
				if len(work.Events) > 0 {
					work.EventID = &work.Events[0].ID
				}
			}
			if profs, ok := profilesByWorkID[work.ID]; ok {
				work.Profiles = profs
			}
			if skls, ok := skillsByWorkID[work.ID]; ok {
				work.Skills = skls
			}
			if imgs, ok := imageMap[work.ID]; ok {
				work.Images = imgs
				work.ImageID = make([]string, len(imgs))
				for i, img := range imgs {
					work.ImageID[i] = img.ID
				}
			}
			if diagImgs, ok := diagramImageMap[work.ID]; ok {
				work.DiagramImages = diagImgs
				work.DiagramImageID = make([]*string, len(diagImgs))
				for i, diagImg := range diagImgs {
					work.DiagramImageID[i] = &diagImg.ImageURL
				}
			}
		}
	}

	hasMore := false
	if len(works) > limit {
		hasMore = true
		works = works[:limit]
	}

	if !forward && len(works) > 0 {
		for i, j := 0, len(works)-1; i < j; i, j = i+1, j-1 {
			works[i], works[j] = works[j], works[i]
		}
	}

	edges := make([]*model.WorkEdge, len(works))
	for i, w := range works {
		cursorStr := model.EncodeCursor(model.Cursor{CreatedAt: w.CreatedAt, ID: w.ID})
		if err != nil {
			log.Printf("Error encoding cursor for work ID %s: %v", w.ID, err)

			return nil, &gqlerror.Error{
				Message: "カーソルのエンコード中にサーバーエラーが発生しました。",
				Extensions: map[string]interface{}{
					"code": "INTERNAL_SERVER_ERROR",
				},
			}
		}
		edges[i] = &model.WorkEdge{
			Node:   w,
			Cursor: cursorStr,
		}
	}

	var startCursorStr, endCursorStr string
	if len(edges) > 0 {
		startCursorStr = edges[0].Cursor
		endCursorStr = edges[len(edges)-1].Cursor
	}

	pageInfo := model.PageInfo{
		StartCursor:     nil,
		EndCursor:       nil,
		HasNextPage:     false,
		HasPreviousPage: false,
	}
	if startCursorStr != "" {
		pageInfo.StartCursor = &startCursorStr
	}
	if endCursorStr != "" {
		pageInfo.EndCursor = &endCursorStr
	}

	if forward {
		pageInfo.HasNextPage = hasMore
		pageInfo.HasPreviousPage = (after != nil && *after != "")
	} else {
		pageInfo.HasPreviousPage = hasMore
		pageInfo.HasNextPage = (before != nil && *before != "")
	}

	return &model.WorkConnection{
		Edges:    edges,
		PageInfo: pageInfo,
	}, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *workResolver) CreatedAt(ctx context.Context, obj *model.Work) (string, error) {
	return obj.CreatedAt.Format(time.RFC3339), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *workResolver) UpdatedAt(ctx context.Context, obj *model.Work) (string, error) {
	return obj.UpdatedAt.Format(time.RFC3339), nil
}

// EventID is the resolver for the eventId field.
func (r *workResolver) EventID(ctx context.Context, obj *model.Work) (*string, error) {
	return obj.EventID, nil
}

// ImageURL is the resolver for the imageUrl field.
func (r *workResolver) ImageURL(ctx context.Context, obj *model.Work) ([]string, error) {
	if obj.Images == nil {
		return []string{}, nil
	}
	urls := make([]string, len(obj.Images))
	for i, img := range obj.Images {
		urls[i] = img.ImageURL
	}
	return urls, nil
}

// DiagramImageURL is the resolver for the diagramImageUrl field.
func (r *workResolver) DiagramImageURL(ctx context.Context, obj *model.Work) ([]*string, error) {
	if obj.DiagramImages == nil {
		return []*string{}, nil
	}
	urls := make([]*string, len(obj.DiagramImages))
	for i, img := range obj.DiagramImages {
		urls[i] = &img.ImageURL
	}
	return urls, nil
}

// Event is the resolver for the event field.
func (r *workResolver) Event(ctx context.Context, obj *model.Work) ([]*model.Event, error) {
	if obj.Events == nil {
		return []*model.Event{}, nil
	}
	return obj.Events, nil
}

// Profile is the resolver for the profile field.
func (r *workResolver) Profile(ctx context.Context, obj *model.Work) ([]*model.Profile, error) {
	if obj.Profiles == nil {
		return []*model.Profile{}, nil
	}
	profiles := make([]*model.Profile, len(obj.Profiles))
	for i, p := range obj.Profiles {
		profiles[i] = &p
	}
	return profiles, nil
}

// Work returns graph.WorkResolver implementation.
func (r *Resolver) Work() graph.WorkResolver { return &workResolver{r} }

type workResolver struct{ *Resolver }
