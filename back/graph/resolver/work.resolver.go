package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/noonyuu/nfc/back/graph"
	"github.com/noonyuu/nfc/back/graph/model"
)

// CreateWork is the resolver for the createWork field.
func (r *mutationResolver) CreateWork(ctx context.Context, input model.NewWork) (*model.Work, error) {
	// uuidを生成
	uid, _ := uuid.NewRandom()
	// 生成したUUIDを文字列に変換
	uidString := uid.String()
	// 現在時刻を取得
	now := time.Now()
	// Work構造体にUUIDと現在時刻をセット
	work := &model.Work{
		ID:          uidString,
		Title:       input.Title,
		Description: *input.Description,
		ImageURL:    input.ImageURL,
		CreatedAt:   now,
		UpdatedAt:   now,
	}
	query := `
	INSERT INTO works (id, title, description, image_url, created_at, updated_at)
	VALUES (?, ?, ?, ?, ?, ?)
`
	if _, err := r.DB.Exec(query, work.ID, work.Title, work.Description, work.ImageURL, now, now); err != nil {
		return nil, err
	}

	return work, nil
}

// CreateProjectEvent is the resolver for the createProjectEvent field.
func (r *mutationResolver) CreateProjectEvent(ctx context.Context, input model.NewCreateProjectEvent) (*model.Work, error) {
	// uuidを生成
	uid, _ := uuid.NewRandom()
	// 生成したUUIDを文字列に変換
	uidString := uid.String()
	// 現在時刻を取得
	now := time.Now()

	if input.WorkID == nil {
		// Work構造体にUUIDと現在時刻をセット
		work := &model.Work{
			ID:          uidString,
			Title:       input.Title,
			Description: input.Description,
			ImageURL:    input.ImageURL,
			EventID:     input.EventID,
			UserID:      input.UserID,
			CreatedAt:   now,
			UpdatedAt:   now,
		}

		// workを登録
		query := `
				INSERT INTO works (id, title, description, image_url, created_at, updated_at)
				VALUES (?, ?, ?, ?, ?, ?)
			`
		if _, err := r.DB.Exec(query, work.ID, work.Title, work.Description, work.ImageURL, now, now); err != nil {
			return nil, err
		}

		// workとskillを結びつける関連テーブルの登録は
		for _, skillId := range input.Skills {
			query = `
			INSERT INTO work_skills (work_id, skill_id, created_at, updated_at)
			VALUES (?, ?, ?, ?)
		`
			if _, err := r.DB.Exec(query, work.ID, skillId, now, now); err != nil {
				return nil, err
			}
		}

		// useridとworkidを結びつける関連テーブルの登録は、
		query = `
				INSERT INTO work_profiles (work_id, profile_id, created_at, updated_at)
				VALUES (?, ?, ?, ?)
			`
		if _, err := r.DB.Exec(query, work.ID, input.UserID, now, now); err != nil {
			return nil, err
		}

		// eventidとworkidを結びつける関連テーブルの登録は
		query = `
			INSERT INTO work_events (work_id, event_id, created_at, updated_at)
			VALUES (?, ?, ?, ?)
		`
		if _, err := r.DB.Exec(query, work.ID, input.EventID, now, now); err != nil {
			return nil, err
		}

		return work, nil
	}

	// eventidとworkidを結びつける
	query := `
			INSERT INTO work_events (work_id, event_id, created_at, updated_at)
			VALUES (?, ?, ?, ?)
		`
	if _, err := r.DB.Exec(query, *input.WorkID, input.EventID, now, now); err != nil {
		return nil, err
	}

	// workを取得
	query = `
		SELECT w.id, w.title, w.description, w.image_url, w.created_at, w.updated_at
		FROM works w
		WHERE w.id = ?
	`
	work := &model.Work{}
	if err := r.DB.QueryRow(query, *input.WorkID).Scan(
		&work.ID,
		&work.Title,
		&work.Description,
		&work.ImageURL,
		&work.CreatedAt,
		&work.UpdatedAt); err != nil {
		return nil, err
	}

	// メモリ上のみにEventIDとUserIDを設定
	work.EventID = input.EventID
	work.UserID = input.UserID

	return work, nil
}

// Work is the resolver for the work field.
func (r *queryResolver) Work(ctx context.Context, id string) (*model.Work, error) {
	query := `
	SELECT id, title, image_url, description, created_at, updated_at
	FROM works
	WHERE id = ?
`
	work := &model.Work{}
	if err := r.DB.QueryRow(query, id).Scan(&work.ID, &work.Title, &work.ImageURL, &work.Description, &work.CreatedAt, &work.UpdatedAt); err != nil {
		return nil, err
	}

	// 取得したworkのIDを使って、関連するeventを取得
	query = `
		SELECT e.id, e.name
		FROM events e
		JOIN work_events we ON e.id = we.event_id
		WHERE we.work_id = ?
	`
	rows, err := r.DB.Query(query, work.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var events []*model.Event
	for rows.Next() {
		event := &model.Event{}
		if err := rows.Scan(&event.ID, &event.Name); err != nil {
			return nil, err
		}
		events = append(events, event)
	}
	work.Events = events
	// 取得したworkのIDを使って、関連するprofileを取得
	query = `
		SELECT p.id, p.avatar_url, p.nick_name
		FROM profiles p
		JOIN work_profiles wp ON p.id = wp.profile_id
		WHERE wp.work_id = ?
	`
	rows, err = r.DB.Query(query, work.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var profiles []*model.Profile
	for rows.Next() {
		profile := &model.Profile{}
		if err := rows.Scan(&profile.ID, &profile.AvatarURL, &profile.NickName); err != nil {
			return nil, err
		}
		profiles = append(profiles, profile)
	}
	work.Profiles = profiles
	// 取得したworkのIDを使って、関連するskillを取得
	query = `
		SELECT s.id, s.name
		FROM skills s
		JOIN work_skills ws ON s.id = ws.skill_id
		WHERE ws.work_id = ?
	`
	rows, err = r.DB.Query(query, work.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var skills []*model.Skill
	for rows.Next() {
		skill := &model.Skill{}
		if err := rows.Scan(&skill.ID, &skill.Name); err != nil {
			return nil, err
		}
		skills = append(skills, skill)
	}
	work.Skills = skills

	return work, nil
}

// WorksByTitle is the resolver for the worksByTitle field.
func (r *queryResolver) WorksByTitle(ctx context.Context, title string) ([]*model.Work, error) {
	query := `
	SELECT id, event_id, title, description, image_url, created_at, updated_at
	FROM works
	WHERE title = ?
`
	rows, err := r.DB.Query(query, title)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var works []*model.Work
	for rows.Next() {
		work := &model.Work{}
		if err := rows.Scan(&work.ID, &work.Title, &work.Description, &work.CreatedAt, &work.UpdatedAt); err != nil {
			return nil, err
		}
		works = append(works, work)
	}

	return works, nil
}

// WorkList is the resolver for the workList field.
func (r *queryResolver) WorkList(ctx context.Context, first *int32, after *string, last *int32, before *string) (*model.WorkConnection, error) {
	limit := 3
	forward := true

	if first != nil {
		limit = int(*first)
		forward = true
	} else if last != nil {
		limit = int(*last)
		forward = false
	}

	var afterCurs, beforeCurs *model.Cursor
	var err error

	if after != nil && *after != "" {
		log.Printf("Received after cursor: %s", *after)
		afterCurs, err = model.DecodeCursor(*after)
		if err != nil {
			return nil, fmt.Errorf("invalid after cursor: %w", err)
		}
	}

	if before != nil && *before != "" {
		beforeCurs, err = model.DecodeCursor(*before)
		if err != nil {
			return nil, fmt.Errorf("invalid before cursor: %w", err)
		}
	}

	orderDirection := "DESC"
	comparisonOp1 := "<"
	comparisonOp2 := "<"
	if !forward {
		orderDirection = "ASC"
		comparisonOp1 = ">"
		comparisonOp2 = ">"
	}

	whereConditions := []string{}
	args := []interface{}{}

	if forward && afterCurs != nil {
		whereConditions = append(whereConditions,
			fmt.Sprintf("(created_at %s ? OR (created_at = ? AND id %s ?))", comparisonOp1, comparisonOp2),
		)
		args = append(args, afterCurs.CreatedAt, afterCurs.CreatedAt, afterCurs.ID)
	} else if !forward && beforeCurs != nil {
		whereConditions = append(whereConditions,
			fmt.Sprintf("(created_at %s ? OR (created_at = ? AND id %s ?))", comparisonOp1, comparisonOp2),
		)
		args = append(args, beforeCurs.CreatedAt, beforeCurs.CreatedAt, beforeCurs.ID)
	}

	whereClause := ""
	if len(whereConditions) > 0 {
		whereClause = "WHERE " + strings.Join(whereConditions, " AND ")
	}

	query := fmt.Sprintf(`
		SELECT id, title, description, image_url, created_at, updated_at
		FROM works
		%s
		ORDER BY created_at %s, id %s
		LIMIT ?
	`, whereClause, orderDirection, orderDirection)

	args = append(args, limit+1)

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	works := []*model.Work{}
	for rows.Next() {
		w := &model.Work{}
		if err := rows.Scan(&w.ID, &w.Title, &w.Description, &w.ImageURL, &w.CreatedAt, &w.UpdatedAt); err != nil {
			return nil, err
		}
		works = append(works, w)
	}

	hasMore := false
	if len(works) > limit {
		hasMore = true
		works = works[:limit]
	}

	// ASC で取ったときは並びを戻す必要あり
	if !forward {
		for i, j := 0, len(works)-1; i < j; i, j = i+1, j-1 {
			works[i], works[j] = works[j], works[i]
		}
	}

	edges := make([]*model.WorkEdge, len(works))
	for i, w := range works {
		edges[i] = &model.WorkEdge{
			Node:   w,
			Cursor: model.EncodeCursor(model.Cursor{CreatedAt: w.CreatedAt, ID: w.ID}),
		}
	}

	var startCursor, endCursor string
	if len(edges) > 0 {
		startCursor = edges[0].Cursor
		endCursor = edges[len(edges)-1].Cursor
	}

	pageInfo := model.PageInfo{
		StartCursor:     startCursor,
		EndCursor:       endCursor,
		HasNextPage:     false,
		HasPreviousPage: false,
	}

	if forward {
		pageInfo.HasNextPage = hasMore
		pageInfo.HasPreviousPage = after != nil && *after != ""
	} else {
		pageInfo.HasPreviousPage = hasMore
		pageInfo.HasNextPage = before != nil && *before != ""
	}

	return &model.WorkConnection{
		Edges:    edges,
		PageInfo: pageInfo,
	}, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *workResolver) CreatedAt(ctx context.Context, obj *model.Work) (string, error) {
	return obj.CreatedAt.Format("2006-01-02 15:04:05"), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *workResolver) UpdatedAt(ctx context.Context, obj *model.Work) (string, error) {
	return obj.UpdatedAt.Format("2006-01-02 15:04:05"), nil
}

// EventID is the resolver for the eventId field.
func (r *workResolver) EventID(ctx context.Context, obj *model.Work) (string, error) {
	return obj.EventID, nil
}

// UserID is the resolver for the userId field.
func (r *workResolver) UserID(ctx context.Context, obj *model.Work) (string, error) {
	return obj.UserID, nil
}

// Event is the resolver for the event field.
func (r *workResolver) Event(ctx context.Context, obj *model.Work) ([]*model.Event, error) {
	return obj.Events, nil
}

// Profile is the resolver for the profile field.
func (r *workResolver) Profile(ctx context.Context, obj *model.Work) ([]*model.Profile, error) {
	return obj.Profiles, nil
}

// Work returns graph.WorkResolver implementation.
func (r *Resolver) Work() graph.WorkResolver { return &workResolver{r} }

type workResolver struct{ *Resolver }
