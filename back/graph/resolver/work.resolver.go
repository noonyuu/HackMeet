package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/noonyuu/nfc/back/graph"
	"github.com/noonyuu/nfc/back/graph/model"
)

// CreateWork is the resolver for the createWork field.
func (r *mutationResolver) CreateWork(ctx context.Context, input model.NewWork) (*model.Work, error) {
	// uuidを生成
	uid, _ := uuid.NewRandom()
	// 生成したUUIDを文字列に変換
	uidString := uid.String()
	// 現在時刻を取得
	now := time.Now()
	// Work構造体にUUIDと現在時刻をセット
	work := &model.Work{
		ID:          uidString,
		Title:       input.Title,
		Description: "",
		ImageURL:    input.ImageURL,
		CreatedAt:   now,
		UpdatedAt:   now,
		UserIDs:     input.UserIds,
	}

	if input.Description != nil {
		work.Description = *input.Description
	}

	// トランザクションを開始
	tx, err := r.DB.BeginTx(ctx, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer func() {
		if p := recover(); p != nil {
			log.Printf("Panic recovered, rolling back: %v", p)
			tx.Rollback()
			panic(p)
		} else if err != nil { // 名前付きリターンerrをチェック
			log.Printf("Error occurred [%v], rolling back.", err)
			if rbErr := tx.Rollback(); rbErr != nil {
				log.Printf("Error during deferred rollback: %v", rbErr)
			}
		} else {
			// 正常終了の場合はコミットされるので何もしない
		}
	}()

	query := `
		INSERT INTO works (id, title, description, image_url, created_at, updated_at)
		VALUES (?, ?, ?, ?, ?, ?)
	`
	if _, err = tx.ExecContext(ctx, query, work.ID, work.Title, work.Description, work.ImageURL, now, now); err != nil {
		log.Printf("Error inserting into works with transaction: %v", err) // ログ追加
		// err 変数にエラーをセットし、deferでロールバックされるようにする
		return nil, fmt.Errorf("failed to insert work with transaction: %w", err)
	}

	// work_skills テーブルへの保存
	if len(input.Skills) > 0 {
		skillQuery := `INSERT INTO work_skills (work_id, skill_id, created_at, updated_at) VALUES (?, ?, ?, ?)`
		for _, skillID := range input.Skills {
			if _, err := tx.ExecContext(ctx, skillQuery, work.ID, skillID, now, now); err != nil {
				return nil, fmt.Errorf("failed to insert work_skill: %w", err)
			}
		}
	}

	// work_profiles テーブルへの保存
	if len(input.UserIds) > 0 {
		profileQuery := `INSERT INTO work_profiles (work_id, profile_id, created_at, updated_at) VALUES (?, ?, ?, ?)`
		for _, userID := range input.UserIds {
			if _, err := tx.ExecContext(ctx, profileQuery, work.ID, userID, now, now); err != nil {
				return nil, fmt.Errorf("failed to insert work_profile: %w", err)
			}
		}
	}

	if err := tx.Commit(); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return work, nil
}

// CreateProjectEvent is the resolver for the createProjectEvent field.
func (r *mutationResolver) CreateProjectEvent(ctx context.Context, input model.NewCreateProjectEvent) (respWork *model.Work, err error) { // 名前付きリターンパラメータ
	now := time.Now()
	var workID string

	tx, txErr := r.DB.BeginTx(ctx, nil)
	if txErr != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", txErr)
	}
	defer func() {
		if p := recover(); p != nil {
			log.Printf("Panic recovered in CreateProjectEvent, rolling back: %v", p)
			_ = tx.Rollback() // Rollbackエラーはここでは無視することも多いが、ログは推奨
			panic(p)
		} else if err != nil { // 名前付きリターンパラメータ 'err' をチェック
			log.Printf("Error occurred in CreateProjectEvent [%v], rolling back.", err)
			if rbErr := tx.Rollback(); rbErr != nil {
				log.Printf("Error during deferred rollback: %v", rbErr)
			}
		}
		// err が nil の場合は、Commitが成功したか、Commitの必要がなかった(エラー早期リターン)
	}()

	// 返却用Workオブジェクトの準備
	respWork = &model.Work{
		Title:       input.Title,
		Description: input.Description, // バリデーションで必須チェックされている想定
		ImageURL:    input.ImageURL,
		CreatedAt:   now,
		UpdatedAt:   now,
		EventID:     input.EventID,
		UserIDs:     input.UserIds,
	}

	if input.WorkID == nil { // 新規 Work 作成
		uid, _ := uuid.NewRandom()
		workID = uid.String()
		respWork.ID = workID

		log.Printf("Attempting to insert new work: %s", workID)
		query := `
            INSERT INTO works (id, title, description, image_url, created_at, updated_at)
            VALUES (?, ?, ?, ?, ?, ?)
        `
		if _, execErr := tx.ExecContext(ctx, query, respWork.ID, respWork.Title, respWork.Description, respWork.ImageURL, respWork.CreatedAt, respWork.UpdatedAt); execErr != nil {
			err = fmt.Errorf("failed to insert work: %w", execErr)
			log.Printf("Error: %v", err)
			return nil, err // defer が err を見てロールバック
		}
		log.Printf("Successfully inserted work: %s", workID)

		// work_skills の登録
		if len(input.Skills) > 0 {
			skillQuery := `INSERT INTO work_skills (work_id, skill_id, created_at, updated_at) VALUES (?, ?, ?, ?)`
			for _, skillID := range input.Skills {
				if _, execErr := tx.ExecContext(ctx, skillQuery, workID, skillID, now, now); execErr != nil {
					err = fmt.Errorf("failed to insert work_skill for new work: %w", execErr)
					log.Printf("Error: %v", err)
					return nil, err
				}
			}
			log.Printf("Successfully inserted work_skills for work: %s", workID)
		}

		// work_profiles の登録
		if len(input.UserIds) > 0 {
			profileQuery := `INSERT INTO work_profiles (work_id, profile_id, created_at, updated_at) VALUES (?, ?, ?, ?)`
			for _, userID := range input.UserIds {
				if _, execErr := tx.ExecContext(ctx, profileQuery, workID, userID, now, now); execErr != nil {
					err = fmt.Errorf("failed to insert work_profile for new work: %w", execErr)
					log.Printf("Error: %v", err)
					return nil, err
				}
			}
			log.Printf("Successfully inserted work_profiles for work: %s", workID)
		}

		// work_events の登録
		if input.EventID != nil {
			// 前回の外部キーエラーの修正がDBスキーマに適用されているか確認してください。
			// (work_events.event_id が events.id を参照するように)
			eventQuery := `INSERT INTO work_events (work_id, event_id, created_at, updated_at) VALUES (?, ?, ?, ?)`
			if _, execErr := tx.ExecContext(ctx, eventQuery, workID, *input.EventID, now, now); execErr != nil {
				err = fmt.Errorf("failed to insert work_event for new work: %w", execErr)
				log.Printf("Error: %v", err)
				return nil, err
			}
			log.Printf("Successfully inserted work_event for work: %s", workID)
		}
	} else { // 既存 Work へのイベント紐付け (現在のコードではイベント紐付けのみ)
		workID = *input.WorkID
		respWork.ID = workID

		if input.EventID == nil {
			err = fmt.Errorf("EventID is required when linking to an existing work via CreateProjectEvent")
			log.Printf("Error: %v", err)
			return nil, err
		}

		log.Printf("Attempting to insert work_event for existing work: %s, event_id: %s", workID, *input.EventID)
		eventQuery := `INSERT INTO work_events (work_id, event_id, created_at, updated_at) VALUES (?, ?, ?, ?)`
		if _, execErr := tx.ExecContext(ctx, eventQuery, workID, *input.EventID, now, now); execErr != nil {
			err = fmt.Errorf("failed to insert work_event for existing work %s: %w", workID, execErr)
			log.Printf("Error: %v", err)
			return nil, err
		}
		log.Printf("Successfully inserted work_event for existing work: %s", workID)
		// 注意: このパスでは、respWorkのTitle, Descriptionなどはinputから来た値のままです。
		// 既存のWorkの最新情報を返したい場合は、ここでDBからWorkを再取得する必要があります。
	}

	// 全ての処理が成功した場合、トランザクションをコミット
	if commitErr := tx.Commit(); commitErr != nil {
		err = fmt.Errorf("failed to commit transaction: %w", commitErr)
		log.Printf("Error committing transaction: %v", err)
		return nil, err
	}

	log.Printf("Transaction committed successfully for work_id: %s", workID)
	return respWork, nil // 正常終了、err は nil
}

// Work is the resolver for the work field.
func (r *queryResolver) Work(ctx context.Context, id string) (*model.Work, error) {
	query := `
		SELECT id, title, image_url, description, created_at, updated_at, event_id
		FROM works
		WHERE id = ?
	`
	work := &model.Work{}
	// event_id を受け取るためにScanの引数を増やす
	var eventID sql.NullString // event_idがNULLの場合に対応
	if err := r.DB.QueryRowContext(ctx, query, id).Scan(&work.ID, &work.Title, &work.ImageURL, &work.Description, &work.CreatedAt, &work.UpdatedAt, &eventID); err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("work with id %s not found", id)
		}
		return nil, err
	}
	if eventID.Valid {
		work.EventID = &eventID.String
	}

	var userIDs []string
	profileQuery := `SELECT profile_id FROM work_profiles WHERE work_id = ?`
	profileRows, err := r.DB.QueryContext(ctx, profileQuery, work.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to query user IDs for work: %w", err)
	}
	defer profileRows.Close()
	for profileRows.Next() {
		var userID string
		if err := profileRows.Scan(&userID); err != nil {
			return nil, fmt.Errorf("failed to scan user ID: %w", err)
		}
		userIDs = append(userIDs, userID)
	}
	work.UserIDs = userIDs

	// 取得したworkのIDを使って、関連するeventを取得
	eventQuery := `
		SELECT e.id, e.name
		FROM events e
		JOIN work_events we ON e.id = we.event_id
		WHERE we.work_id = ?
	`
	event_rows, err := r.DB.QueryContext(ctx, eventQuery, work.ID)
	if err != nil {
		return nil, err
	}
	defer event_rows.Close()
	var events []*model.Event
	for event_rows.Next() {
		event := &model.Event{}
		if err := event_rows.Scan(&event.ID, &event.Name); err != nil {
			return nil, err
		}
		events = append(events, event)
	}
	if len(events) > 0 { // イベントがある場合のみセット
		work.Events = events
	} else {
		work.Events = make([]*model.Event, 0)
	}

	// 取得したworkのIDを使って、関連するprofileを取得
	profileObjQuery := `
		SELECT p.id, p.avatar_url, p.nick_name
		FROM profiles p
		JOIN work_profiles wp ON p.id = wp.profile_id
		WHERE wp.work_id = ?
	`
	profileObjRows, err := r.DB.QueryContext(ctx, profileObjQuery, work.ID)
	if err != nil {
		return nil, err
	}
	defer profileObjRows.Close()
	var profiles []model.Profile
	for profileObjRows.Next() {
		profile := model.Profile{}
		if err := profileObjRows.Scan(&profile.ID, &profile.AvatarURL, &profile.NickName); err != nil {
			return nil, err
		}
		profiles = append(profiles, profile) // profileをそのまま追加
	}
	if len(profiles) > 0 {
		work.Profiles = profiles
	} else {
		work.Profiles = make([]model.Profile, 0) // GraphQLスキーマに合わせる
	}

	// 取得したworkのIDを使って、関連するskillを取得
	skillQuery := `
		SELECT s.id, s.name
		FROM skills s
		JOIN work_skills ws ON s.id = ws.skill_id
		WHERE ws.work_id = ?
	`
	skill_rows, err := r.DB.QueryContext(ctx, skillQuery, work.ID)
	if err != nil {
		return nil, err
	}
	defer skill_rows.Close()
	var skills []model.Skill
	for skill_rows.Next() {
		skill := model.Skill{}
		if err := skill_rows.Scan(&skill.ID, &skill.Name); err != nil {
			return nil, err
		}
		skills = append(skills, skill) // skillをそのまま追加
	}
	if len(skills) > 0 {
		work.Skills = skills
	} else {
		work.Skills = make([]model.Skill, 0)
	}

	return work, nil
}

// WorksByTitle is the resolver for the worksByTitle field.
func (r *queryResolver) WorksByTitle(ctx context.Context, title string) ([]*model.Work, error) {
	query := `
		SELECT id, event_id, title, description, image_url, created_at, updated_at
		FROM works
		WHERE title = ?
	`
	base_rows, err := r.DB.QueryContext(ctx, query, title)
	if err != nil {
		return nil, err
	}
	defer base_rows.Close()

	var works []*model.Work
	for base_rows.Next() {
		work := &model.Work{}
		var eventID sql.NullString
		if err := base_rows.Scan(&work.ID, &work.Title, &work.Description, &work.ImageURL, &work.CreatedAt, &work.UpdatedAt, &eventID); err != nil {
			return nil, err
		}
		if eventID.Valid {
			work.EventID = &eventID.String
		}
		works = append(works, work)
	}

	return works, nil
}

// WorkList is the resolver for the workList field.
func (r *queryResolver) WorkList(ctx context.Context, first *int32, after *string, last *int32, before *string) (*model.WorkConnection, error) {
	limit := 3
	forward := true

	if first != nil {
		limit = int(*first)
		forward = true
	} else if last != nil {
		limit = int(*last)
		forward = false
	}

	var afterCurs, beforeCurs *model.Cursor
	var err error

	if after != nil && *after != "" {
		log.Printf("Received after cursor: %s", *after)
		afterCurs, err = model.DecodeCursor(*after)
		if err != nil {
			return nil, fmt.Errorf("invalid after cursor: %w", err)
		}
	}

	if before != nil && *before != "" {
		beforeCurs, err = model.DecodeCursor(*before)
		if err != nil {
			return nil, fmt.Errorf("invalid before cursor: %w", err)
		}
	}

	orderDirection := "DESC"
	comparisonOp1 := "<"
	comparisonOp2 := "<"
	if !forward {
		orderDirection = "ASC"
		comparisonOp1 = ">"
		comparisonOp2 = ">"
	}

	whereConditions := []string{}
	args := []interface{}{}

	if forward && afterCurs != nil {
		whereConditions = append(whereConditions,
			fmt.Sprintf("(created_at %s ? OR (created_at = ? AND id %s ?))", comparisonOp1, comparisonOp2),
		)
		args = append(args, afterCurs.CreatedAt, afterCurs.CreatedAt, afterCurs.ID)
	} else if !forward && beforeCurs != nil {
		whereConditions = append(whereConditions,
			fmt.Sprintf("(created_at %s ? OR (created_at = ? AND id %s ?))", comparisonOp1, comparisonOp2),
		)
		args = append(args, beforeCurs.CreatedAt, beforeCurs.CreatedAt, beforeCurs.ID)
	}

	whereClause := ""
	if len(whereConditions) > 0 {
		whereClause = "WHERE " + strings.Join(whereConditions, " AND ")
	}

	// SQLクエリから event_id を削除
	query := fmt.Sprintf(`
		SELECT id, title, description, image_url, created_at, updated_at
		FROM works
		%s
		ORDER BY created_at %s, id %s
		LIMIT ?
	`, whereClause, orderDirection, orderDirection)

	args = append(args, limit+1)

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to query works: %w", err)
	}
	defer rows.Close()

	works := []*model.Work{}
	for rows.Next() {
		w := &model.Work{}
		// rows.Scan から event_id のスキャンを削除
		if err := rows.Scan(&w.ID, &w.Title, &w.Description, &w.ImageURL, &w.CreatedAt, &w.UpdatedAt); err != nil {
			rows.Close()
			return nil, fmt.Errorf("failed to scan work: %w", err)
		}
		works = append(works, w)
	}
	if err = rows.Err(); err != nil {
		return nil, fmt.Errorf("error during rows iteration: %w", err)
	}

	if len(works) > 0 {
		workIDs := make([]string, 0, len(works))
		for _, w := range works {
			workIDs = append(workIDs, w.ID)
			w.Events = make([]*model.Event, 0)
			w.Profiles = make([]model.Profile, 0)
			w.Skills = make([]model.Skill, 0)
			w.UserIDs = make([]string, 0)
		}

		placeholders := make([]string, len(workIDs))
		idArgs := make([]interface{}, len(workIDs))
		for i, id := range workIDs {
			placeholders[i] = "?"
			idArgs[i] = id
		}
		inClause := strings.Join(placeholders, ",")

		userIDsQuery := fmt.Sprintf(`SELECT work_id, profile_id FROM work_profiles WHERE work_id IN (%s)`, inClause)
		userIDRows, err := r.DB.QueryContext(ctx, userIDsQuery, idArgs...)
		if err != nil {
			return nil, fmt.Errorf("failed to query user IDs for work list: %w", err)
		}
		userIDsByWorkID := make(map[string][]string)
		for userIDRows.Next() {
			var workID, userID string
			if err := userIDRows.Scan(&workID, &userID); err != nil {
				userIDRows.Close()
				return nil, fmt.Errorf("failed to scan work_id/profile_id: %w", err)
			}
			userIDsByWorkID[workID] = append(userIDsByWorkID[workID], userID)
		}
		userIDRows.Close()
		if err = userIDRows.Err(); err != nil {
			return nil, fmt.Errorf("error during userIDRows iteration: %w", err)
		}

		eventQuery := fmt.Sprintf(`
			SELECT we.work_id, e.id, e.name
			FROM events e
			JOIN work_events we ON e.id = we.event_id
			WHERE we.work_id IN (%s)`, inClause)
		eventRows, err := r.DB.QueryContext(ctx, eventQuery, idArgs...)
		if err != nil {
			return nil, fmt.Errorf("failed to query events for work list: %w", err)
		}
		eventsByWorkID := make(map[string][]*model.Event)
		for eventRows.Next() {
			var workID string
			event := &model.Event{}
			if err := eventRows.Scan(&workID, &event.ID, &event.Name); err != nil {
				eventRows.Close()
				return nil, fmt.Errorf("failed to scan event for work list: %w", err)
			}
			eventsByWorkID[workID] = append(eventsByWorkID[workID], event)
		}
		eventRows.Close()
		if err = eventRows.Err(); err != nil {
			return nil, fmt.Errorf("error during eventRows iteration: %w", err)
		}

		profileQuery := fmt.Sprintf(`
			SELECT wp.work_id, p.id, p.avatar_url, p.nick_name
			FROM profiles p
			JOIN work_profiles wp ON p.id = wp.profile_id
			WHERE wp.work_id IN (%s)`, inClause)
		profileRows, err := r.DB.QueryContext(ctx, profileQuery, idArgs...)
		if err != nil {
			return nil, fmt.Errorf("failed to query profiles for work list: %w", err)
		}
		profilesByWorkID := make(map[string][]model.Profile)
		for profileRows.Next() {
			var workID string
			profile := model.Profile{}
			if err := profileRows.Scan(&workID, &profile.ID, &profile.AvatarURL, &profile.NickName); err != nil {
				profileRows.Close()
				return nil, fmt.Errorf("failed to scan profile for work list: %w", err)
			}
			profilesByWorkID[workID] = append(profilesByWorkID[workID], profile)
		}
		profileRows.Close()
		if err = profileRows.Err(); err != nil {
			return nil, fmt.Errorf("error during profileRows iteration: %w", err)
		}

		skillQuery := fmt.Sprintf(`
			SELECT ws.work_id, s.id, s.name
			FROM skills s
			JOIN work_skills ws ON s.id = ws.skill_id
			WHERE ws.work_id IN (%s)`, inClause)
		skillRows, err := r.DB.QueryContext(ctx, skillQuery, idArgs...)
		if err != nil {
			return nil, fmt.Errorf("failed to query skills for work list: %w", err)
		}
		skillsByWorkID := make(map[string][]model.Skill)
		for skillRows.Next() {
			var workID string
			skill := model.Skill{}
			if err := skillRows.Scan(&workID, &skill.ID, &skill.Name); err != nil {
				skillRows.Close()
				return nil, fmt.Errorf("failed to scan skill for work list: %w", err)
			}
			skillsByWorkID[workID] = append(skillsByWorkID[workID], skill)
		}
		skillRows.Close()
		if err = skillRows.Err(); err != nil {
			return nil, fmt.Errorf("error during skillRows iteration: %w", err)
		}

		for _, work := range works {
			if ids, ok := userIDsByWorkID[work.ID]; ok {
				work.UserIDs = ids
			}
			if evts, ok := eventsByWorkID[work.ID]; ok {
				work.Events = evts
				// --- ここで EventID を設定 ---
				if len(work.Events) > 0 {
					// 最初のイベントのIDを work.EventID に設定
					// work.Events[0] が nil でないことを保証する必要があるが、
					// eventsByWorkID に追加する際に nil の event は含めていない前提
					work.EventID = &work.Events[0].ID
				}
			}
			if profs, ok := profilesByWorkID[work.ID]; ok {
				work.Profiles = profs
			}
			if skls, ok := skillsByWorkID[work.ID]; ok {
				work.Skills = skls
			}
		}
	}

	hasMore := false
	if len(works) > limit {
		hasMore = true
		works = works[:limit]
	}

	if !forward && len(works) > 0 {
		for i, j := 0, len(works)-1; i < j; i, j = i+1, j-1 {
			works[i], works[j] = works[j], works[i]
		}
	}

	edges := make([]*model.WorkEdge, len(works))
	for i, w := range works {
		cursorStr := model.EncodeCursor(model.Cursor{CreatedAt: w.CreatedAt, ID: w.ID})
		if err != nil {
			return nil, fmt.Errorf("failed to encode cursor for work %s: %w", w.ID, err)
		}
		edges[i] = &model.WorkEdge{
			Node:   w,
			Cursor: cursorStr,
		}
	}

	var startCursorStr, endCursorStr string
	if len(edges) > 0 {
		startCursorStr = edges[0].Cursor
		endCursorStr = edges[len(edges)-1].Cursor
	}

	pageInfo := model.PageInfo{
		StartCursor:     nil, // 初期値はnil
		EndCursor:       nil, // 初期値はnil
		HasNextPage:     false,
		HasPreviousPage: false,
	}
	if startCursorStr != "" {
		pageInfo.StartCursor = &startCursorStr
	}
	if endCursorStr != "" {
		pageInfo.EndCursor = &endCursorStr
	}

	if forward {
		pageInfo.HasNextPage = hasMore
		pageInfo.HasPreviousPage = (after != nil && *after != "")
	} else {
		pageInfo.HasPreviousPage = hasMore
		pageInfo.HasNextPage = (before != nil && *before != "")
	}

	return &model.WorkConnection{
		Edges:    edges,
		PageInfo: pageInfo,
	}, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *workResolver) CreatedAt(ctx context.Context, obj *model.Work) (string, error) {
	return obj.CreatedAt.Format(time.RFC3339), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *workResolver) UpdatedAt(ctx context.Context, obj *model.Work) (string, error) {
	return obj.UpdatedAt.Format(time.RFC3339), nil
}

// EventID is the resolver for the eventId field.
func (r *workResolver) EventID(ctx context.Context, obj *model.Work) (*string, error) {
	return obj.EventID, nil
}

// Event is the resolver for the event field.
func (r *workResolver) Event(ctx context.Context, obj *model.Work) ([]*model.Event, error) {
	if obj.Events == nil {
		return make([]*model.Event, 0), nil
	}
	return obj.Events, nil
}

// Profile is the resolver for the profile field.
func (r *workResolver) Profile(ctx context.Context, obj *model.Work) ([]*model.Profile, error) {
	if obj.Profiles == nil {
		return make([]*model.Profile, 0), nil
	}
	profiles := make([]*model.Profile, len(obj.Profiles))
	for i, p := range obj.Profiles {
		profiles[i] = &p
	}
	return profiles, nil
}

// Work returns graph.WorkResolver implementation.
func (r *Resolver) Work() graph.WorkResolver { return &workResolver{r} }

type workResolver struct{ *Resolver }
