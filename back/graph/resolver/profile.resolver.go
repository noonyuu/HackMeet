package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/noonyuu/nfc/back/graph"
	"github.com/noonyuu/nfc/back/graph/model"
	"github.com/vektah/gqlparser/gqlerror"
)

// CreateProfile is the resolver for the createProfile field.
func (r *mutationResolver) CreateProfile(ctx context.Context, input model.NewProfile) (*model.Profile, error) {
	now := time.Now()

	var avatarURL sql.NullString
	if input.AvatarURL != nil {
		avatarURL = sql.NullString{String: *input.AvatarURL, Valid: true}
	} else {
		avatarURL = sql.NullString{Valid: false}
	}

	var graduationYear sql.NullInt32
	if input.GraduationYear != nil {
		graduationYear = sql.NullInt32{Int32: *input.GraduationYear, Valid: true}
	} else {
		graduationYear = sql.NullInt32{Valid: false}
	}

	var affiliation sql.NullString
	if input.Affiliation != nil {
		affiliation = sql.NullString{String: *input.Affiliation, Valid: true}
	} else {
		affiliation = sql.NullString{Valid: false}
	}

	var bio sql.NullString
	if input.Bio != nil {
		bio = sql.NullString{String: *input.Bio, Valid: true}
	} else {
		bio = sql.NullString{Valid: false}
	}

	profileToInsert := &model.Profile{
		ID:        input.UserID,
		CreatedAt: now,
		UpdatedAt: now,
	}

	if avatarURL.Valid {
		profileToInsert.AvatarURL = avatarURL.String
	} else {
		profileToInsert.AvatarURL = ""
	}

	profileToInsert.NickName = input.NickName

	if graduationYear.Valid {
		profileToInsert.GraduationYear = &graduationYear.Int32
	} else {
		profileToInsert.GraduationYear = nil
	}

	if affiliation.Valid {
		profileToInsert.Affiliation = &affiliation.String
	} else {
		profileToInsert.Affiliation = nil
	}

	if bio.Valid {
		profileToInsert.Bio = &bio.String
	} else {
		profileToInsert.Bio = nil
	}

	query := `
  INSERT INTO profiles (id, avatar_url, nick_name, graduation_year, affiliation, bio, created_at, updated_at)
  VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`
	_, err := r.DB.ExecContext(ctx, query,
		profileToInsert.ID,
		avatarURL,
		profileToInsert.NickName,
		graduationYear,
		affiliation,
		bio,
		profileToInsert.CreatedAt,
		profileToInsert.UpdatedAt,
	)
	if err != nil {
		log.Printf("failed to insert profile: %v", err)

		return nil, &gqlerror.Error{
			Message: "プロフィールの作成中にサーバーエラーが発生しました。",
			Extensions: map[string]interface{}{
				"code": "INTERNAL_SERVER_ERROR",
			},
		}
	}

	return profileToInsert, nil
}

// UpdateProfile is the resolver for the updateProfile field.
func (r *mutationResolver) UpdateProfile(ctx context.Context, input model.UpdateProfile) (*model.Profile, error) {
	// 現在時刻を取得
	now := time.Now()

	// 動的にUPDATE文を構築
	var setParts []string
	var args []interface{}

	// AvatarURLの処理
	if input.AvatarURL != nil {
		setParts = append(setParts, "avatar_url = ?")
		args = append(args, *input.AvatarURL)
	}

	// NickNameの処理
	if input.NickName != nil {
		setParts = append(setParts, "nick_name = ?")
		args = append(args, *input.NickName)
	}

	// GraduationYearの処理
	if input.GraduationYear != nil {
		setParts = append(setParts, "graduation_year = ?")
		var graduationYear sql.NullInt32
		if *input.GraduationYear != 0 { // 0の場合はNULLとして扱う場合
			graduationYear = sql.NullInt32{
				Int32: *input.GraduationYear,
				Valid: true,
			}
		} else {
			graduationYear = sql.NullInt32{Valid: false}
		}
		args = append(args, graduationYear)
	}

	// Affiliationの処理
	if input.Affiliation != nil {
		setParts = append(setParts, "affiliation = ?")
		args = append(args, input.Affiliation)
	}

	// Bioの処理
	if input.Bio != nil {
		setParts = append(setParts, "bio = ?")
		args = append(args, input.Bio)
	}

	// 更新するフィールドがない場合
	if len(setParts) == 0 {
		return nil, &gqlerror.Error{
			Message: "更新するフィールドが指定されていません。",
			Extensions: map[string]interface{}{
				"code": "BAD_REQUEST",
			},
		}
	}

	// updated_atは常に更新
	setParts = append(setParts, "updated_at = ?")
	args = append(args, now)

	// WHERE句のIDを追加
	args = append(args, input.ID)

	updateQuery := fmt.Sprintf(`
		UPDATE profiles
		SET %s
		WHERE id = ?
	`, strings.Join(setParts, ", "))

	result, err := r.DB.ExecContext(ctx, updateQuery, args...)
	if err != nil {
		log.Printf("failed to update profile: %v", err)
		return nil, &gqlerror.Error{
			Message: "プロフィールの更新中にサーバーエラーが発生しました。",
			Extensions: map[string]interface{}{
				"code": "INTERNAL_SERVER_ERROR",
			},
		}
	}

	// 更新されたレコード数を確認
	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("failed to get rows affected: %v", err)
	} else if rowsAffected == 0 {
		return nil, &gqlerror.Error{
			Message: "指定されたプロフィールが見つかりません。",
			Extensions: map[string]interface{}{
				"code": "NOT_FOUND",
			},
		}
	}

	selectQuery := `
	SELECT id, avatar_url, nick_name, graduation_year, affiliation, bio, created_at, updated_at
	FROM profiles
	WHERE id = ?
	`
	row := r.DB.QueryRowContext(ctx, selectQuery, input.ID)

	var fetchedProfile model.Profile
	var dbGraduationYear sql.NullInt32

	if err := row.Scan(
		&fetchedProfile.ID,
		&fetchedProfile.AvatarURL,
		&fetchedProfile.NickName,
		&dbGraduationYear,
		&fetchedProfile.Affiliation,
		&fetchedProfile.Bio,
		&fetchedProfile.CreatedAt,
		&fetchedProfile.UpdatedAt,
	); err != nil {
		if err == sql.ErrNoRows {
			log.Printf("profile with id %s not found after update", input.ID)
			return nil, &gqlerror.Error{
				Message: "プロフィールが見つかりません。",
				Extensions: map[string]interface{}{
					"code": "NOT_FOUND",
				},
			}
		}
		log.Printf("failed to scan updated profile: %v", err)

		return nil, &gqlerror.Error{
			Message: "プロフィールの取得中にサーバーエラーが発生しました。",
			Extensions: map[string]interface{}{
				"code": "INTERNAL_SERVER_ERROR",
			},
		}
	}

	// sql.NullInt32 から model.Profile の *int32 へ変換
	if dbGraduationYear.Valid {
		fetchedProfile.GraduationYear = &dbGraduationYear.Int32
	} else {
		fetchedProfile.GraduationYear = nil
	}

	return &fetchedProfile, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *profileResolver) CreatedAt(ctx context.Context, obj *model.Profile) (string, error) {
	return obj.CreatedAt.Format("2006-01-02 15:04:05"), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *profileResolver) UpdatedAt(ctx context.Context, obj *model.Profile) (string, error) {
	return obj.UpdatedAt.Format("2006-01-02 15:04:05"), nil
}

// Profile is the resolver for the profile field.
func (r *queryResolver) Profile(ctx context.Context, id string) (*model.Profile, error) {
	query := `
  SELECT id, avatar_url, nick_name, graduation_year, affiliation, bio, created_at, updated_at
  FROM profiles
  WHERE id = ?
`
	row := r.DB.QueryRowContext(ctx, query, id)

	var profile model.Profile
	var avatarURL sql.NullString
	var nickName sql.NullString
	var graduationYear sql.NullInt32
	var affiliation sql.NullString
	var bio sql.NullString

	if err := row.Scan(
		&profile.ID,
		&avatarURL,
		&nickName,
		&graduationYear,
		&affiliation,
		&bio,
		&profile.CreatedAt,
		&profile.UpdatedAt,
	); err != nil {
		if err == sql.ErrNoRows {
			log.Printf("profile with id %s not found", id)

			return nil, &gqlerror.Error{
				Message: "プロフィールが見つかりません。",
				Extensions: map[string]interface{}{
					"code": "NOT_FOUND",
				},
			}
		}
		log.Printf("failed to scan profile data for ID %s: %v", id, err)

		return nil, &gqlerror.Error{
			Message: "プロフィールの取得中にサーバーエラーが発生しました。",
			Extensions: map[string]interface{}{
				"code": "INTERNAL_SERVER_ERROR",
			},
		}
	}

	if avatarURL.Valid {
		profile.AvatarURL = avatarURL.String
	} else {
		profile.AvatarURL = ""
	}

	if nickName.Valid {
		profile.NickName = nickName.String
	} else {
		profile.NickName = ""
	}

	if graduationYear.Valid {
		profile.GraduationYear = &graduationYear.Int32
	} else {
		profile.GraduationYear = nil
	}

	if affiliation.Valid {
		profile.Affiliation = &affiliation.String
	} else {
		profile.Affiliation = nil
	}

	if bio.Valid {
		profile.Bio = &bio.String
	} else {
		profile.Bio = nil
	}

	return &profile, nil
}

// ProfileByNickName is the resolver for the profileByNickName field.
func (r *queryResolver) ProfileByNickName(ctx context.Context, nickName string) ([]*model.Profile, error) {
	// 曖昧検索にする
	nickName = "%" + nickName + "%"
	query := `
		SELECT id, avatar_url, nick_name, graduation_year, affiliation, bio, created_at, updated_at
		FROM profiles
		WHERE nick_name LIKE ?
	`

	row := r.DB.QueryRow(query, nickName)

	var profile model.Profile
	var avatarURL sql.NullString
	var nickNames sql.NullString
	var graduationYear sql.NullInt32
	var affiliation sql.NullString
	var bio sql.NullString

	if err := row.Scan(
		&profile.ID,
		&avatarURL,
		&nickNames,
		&graduationYear,
		&affiliation,
		&bio,
		&profile.CreatedAt,
		&profile.UpdatedAt,
	); err != nil {
		if err == sql.ErrNoRows {
			log.Printf("profile with nick name %s not found", nickName)

			return nil, &gqlerror.Error{
				Message: "プロフィールが見つかりません。",
				Extensions: map[string]interface{}{
					"code": "NOT_FOUND",
				},
			}
		}
		log.Printf("failed to scan profile by user name %s: %v", nickName, err)

		return nil, &gqlerror.Error{
			Message: "プロフィールの取得中にサーバーエラーが発生しました。",
			Extensions: map[string]interface{}{
				"code": "INTERNAL_SERVER_ERROR",
			},
		}
	}

	if avatarURL.Valid {
		profile.AvatarURL = avatarURL.String
	} else {
		profile.AvatarURL = ""
	}

	if nickNames.Valid {
		profile.NickName = nickNames.String
	} else {
		profile.NickName = ""
	}

	if graduationYear.Valid {
		profile.GraduationYear = &graduationYear.Int32
	} else {
		profile.GraduationYear = nil
	}

	if affiliation.Valid {
		profile.Affiliation = &affiliation.String
	} else {
		profile.Affiliation = nil
	}

	if bio.Valid {
		profile.Bio = &bio.String
	} else {
		profile.Bio = nil
	}
	return []*model.Profile{&profile}, nil
}

// ProfileByUserID is the resolver for the profileByUserId field.
func (r *queryResolver) ProfileByUserID(ctx context.Context, id string) (*model.Profile, error) {
	query := `
  SELECT id, avatar_url, nick_name, graduation_year, affiliation, bio, created_at, updated_at
  FROM profiles
  WHERE id = ?
  `

	row := r.DB.QueryRowContext(ctx, query, id)

	var profile model.Profile
	var avatarURL sql.NullString
	var nickName sql.NullString
	var graduationYear sql.NullInt32
	var affiliation sql.NullString
	var bio sql.NullString

	if err := row.Scan(
		&profile.ID,
		&avatarURL,
		&nickName,
		&graduationYear,
		&affiliation,
		&bio,
		&profile.CreatedAt,
		&profile.UpdatedAt,
	); err != nil {
		if err == sql.ErrNoRows {
			log.Printf("profile with id %s not found", id)

			return nil, &gqlerror.Error{
				Message: "プロフィールが見つかりません。",
				Extensions: map[string]interface{}{
					"code": "NOT_FOUND",
				},
			}
		}
		log.Printf("failed to scan profile data for ID %s: %v", id, err)

		return nil, &gqlerror.Error{
			Message: "プロフィールの取得中にサーバーエラーが発生しました。",
			Extensions: map[string]interface{}{
				"code": "INTERNAL_SERVER_ERROR",
			},
		}
	}

	if avatarURL.Valid {
		profile.AvatarURL = avatarURL.String
	} else {
		profile.AvatarURL = ""
	}

	if nickName.Valid {
		profile.NickName = nickName.String
	} else {
		profile.NickName = ""
	}

	if graduationYear.Valid {
		profile.GraduationYear = &graduationYear.Int32
	} else {
		profile.GraduationYear = nil
	}

	if affiliation.Valid {
		profile.Affiliation = &affiliation.String
	} else {
		profile.Affiliation = nil
	}

	if bio.Valid {
		profile.Bio = &bio.String
	} else {
		profile.Bio = nil
	}

	return &profile, nil
}

// Profile returns graph.ProfileResolver implementation.
func (r *Resolver) Profile() graph.ProfileResolver { return &profileResolver{r} }

type profileResolver struct{ *Resolver }
